[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ROPESHubDashboard",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "dashboard.html",
    "href": "dashboard.html",
    "title": "ROPES Hub Dashboard",
    "section": "",
    "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"381\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A 4-m-long beam is constructed by nailing together two wooden boards as shown. The nails each have a diameter d = {d()} mm and can withstand a shear stress of 100 MPa. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, determine the maximum permissable spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(5, 15, 1))\n        F1.set(random.randrange(2, 20, 1))\n        F2.set(random.randrange(2, 20, 1))\n        F3.set(random.randrange(2, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V1 = F1()+F3()-F2()\n        V2 = V1-F1()\n        V3 = V2+F2()\n        Vmax = max(abs(V1), abs(V2), abs(V3))\n        I = 11.52*10**-6\n        Q = 1.28*10**-4\n        Taub = Vmax*Q/(I*0.08)\n        instr= (100000*(d()/1000/2)**2*math.pi)/(Taub*0.08)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)"
  }
]